# 矩阵读取模块 (Matrix Reader)

## 概述

矩阵读取模块负责从指定的BRAM矩阵块中读取矩阵数据（包含元数据）。支持按需读取，先返回元数据，然后根据请求逐个返回矩阵数据元素。

## 模块参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `MAX_MEMORY_MATRIXES` | 8 | 最大矩阵块数量 |
| `BLOCK_SIZE` | 1152 | 每个矩阵块大小（32bit字）|
| `DATA_WIDTH` | 32 | 数据位宽 |
| `ADDR_WIDTH` | 14 | 地址位宽 |

## 端口定义

### 时钟和复位

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `clk` | input | 1 | 时钟信号 |
| `rst_n` | input | 1 | 低电平异步复位 |

### 读取请求接口

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `read_req` | input | 1 | 读取请求信号（脉冲）|
| `matrix_id` | input | 3 | 矩阵编号 (0~7) |
| `read_data_req` | input | 1 | 请求读取下一个矩阵数据 |
| `read_done` | output | 1 | 读取完成信号 |
| `reader_ready` | output | 1 | 读取器就绪信号 |

### 元数据输出

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `rows` | output | 8 | 矩阵真实行数 |
| `cols` | output | 8 | 矩阵真实列数 |
| `matrix_name` | output | 64 | 矩阵名称（8个ASCII字符）|
| `meta_valid` | output | 1 | 元数据有效信号 |

### 矩阵数据输出

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `data_out` | output | 32 | 矩阵数据输出 |
| `data_valid` | output | 1 | 数据有效信号 |

### BRAM接口

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `bram_addr` | output | ADDR_WIDTH | BRAM地址 |
| `bram_dout` | input | DATA_WIDTH | BRAM读出数据 |

## 存储格式

读取的矩阵块存储格式（与写入模块相同）：

| 地址偏移 | 内容 | 格式 |
|---------|------|------|
| 0 | 元数据0 | [31:24]=行数, [23:16]=列数, [15:0]=保留 |
| 1 | 元数据1 | 矩阵名称低32位 |
| 2 | 元数据2 | 矩阵名称高32位 |
| 3~1151 | 矩阵数据 | 按行优先顺序存储 |

## 工作流程

### 状态机

模块内部使用状态机控制读取过程：

```text
IDLE → READ_META0 → WAIT_META0 → READ_META1 → WAIT_META1 → 
READ_META2 → WAIT_META2 → READ_DATA → DONE → IDLE
```

| 状态 | 说明 |
|------|------|
| `IDLE` | 空闲状态，等待读取请求 |
| `READ_META0` | 发起读取元数据字0 |
| `WAIT_META0` | 等待并接收元数据字0 |
| `READ_META1` | 发起读取元数据字1 |
| `WAIT_META1` | 等待并接收元数据字1 |
| `READ_META2` | 发起读取元数据字2 |
| `WAIT_META2` | 等待并接收元数据字2，输出元数据 |
| `READ_DATA` | 读取矩阵数据阶段 |
| `DONE` | 读取完成 |

### 读取时序

1. **初始化阶段**
   - 确保 `reader_ready = 1`
   - 准备接收数据

2. **发起读取请求**

   ```text
   时钟周期 0: read_req = 1, matrix_id = X
   时钟周期 1: read_req = 0
   ```

3. **元数据读取（自动完成，共6个周期）**
   - 周期 1-2: 读取地址0，等待1周期
   - 周期 3-4: 读取地址1，等待1周期
   - 周期 5-6: 读取地址2，等待1周期后输出元数据
   - 在第6周期，`meta_valid = 1`，输出 `rows`, `cols`, `matrix_name`

4. **矩阵数据读取**

   ```text
   每当 read_data_req = 1 时：
     - 发起BRAM读取请求
     - 1个周期后，data_valid = 1，data_out 输出数据
   ```

5. **完成**
   - 当所有数据（rows × cols 个元素）读取完成后
   - `read_done` 信号拉高1个周期
   - 返回 `IDLE` 状态

## BRAM读取延迟

BRAM读取有1个时钟周期的延迟：

- 周期 N: 在 `bram_addr` 上设置地址
- 周期 N+1: `bram_dout` 输出该地址的数据

模块内部已处理此延迟。

## 使用示例

### 示例1: 读取矩阵元数据

```systemverilog
// 等待读取器就绪
wait(reader_ready);

// 发起读取请求（读取槽位0）
@(posedge clk);
read_req <= 1'b1;
matrix_id <= 3'd0;
@(posedge clk);
read_req <= 1'b0;

// 等待元数据有效
wait(meta_valid);
@(posedge clk);

// 读取元数据
my_rows = rows;
my_cols = cols;
my_name = matrix_name;

$display("矩阵: %s, 大小: %0d×%0d", my_name, my_rows, my_cols);
```

### 示例2: 读取完整矩阵

```systemverilog
logic [31:0] matrix_data[0:100];
integer total_elements;

// 发起读取请求
read_req <= 1'b1;
matrix_id <= 3'd2;
@(posedge clk);
read_req <= 1'b0;

// 等待并获取元数据
wait(meta_valid);
@(posedge clk);
total_elements = rows * cols;

// 逐个读取矩阵数据
for (int i = 0; i < total_elements; i++) begin
    // 发起读取请求
    read_data_req <= 1'b1;
    @(posedge clk);
    read_data_req <= 1'b0;
    
    // 等待1个周期（BRAM延迟）
    @(posedge clk);
    
    // 数据有效，保存数据
    if (data_valid) begin
        matrix_data[i] = data_out;
    end
end

// 等待读取完成
wait(read_done);
```

### 示例3: 流水线连续读取

```systemverilog
// 连续请求读取（更高效）
for (int i = 0; i < total_elements; i++) begin
    read_data_req <= 1'b1;
    @(posedge clk);
end
read_data_req <= 1'b0;

// 连续接收数据
for (int i = 0; i < total_elements; i++) begin
    @(posedge clk);
    if (data_valid) begin
        matrix_data[i] = data_out;
    end
end
```

## 重要注意事项

1. **读取请求**
   - `read_req` 应该是一个单周期脉冲
   - 发起请求后会自动读取元数据

2. **元数据有效信号**
   - `meta_valid = 1` 时，元数据有效
   - 元数据仅在读取元数据阶段的最后1个周期有效

3. **数据读取延迟**
   - 每次 `read_data_req = 1` 后，需等待1个周期
   - 数据在下一个周期的 `data_out` 上输出，`data_valid = 1`

4. **数据计数**
   - 模块内部自动计算总元素数（rows × cols）
   - 读取完所有元素后自动完成

5. **就绪信号**
   - `reader_ready = 0` 表示读取器正在工作
   - 必须等待 `reader_ready = 1` 才能发起新的读取请求

6. **读写冲突**
   - 如果使用顶层管理器，读写冲突会自动处理
   - 单独使用时，需确保写入完成后再读取
