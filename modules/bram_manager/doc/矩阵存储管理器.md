# 矩阵存储管理器 (Matrix Storage Manager)

## 概述

矩阵存储管理器是顶层模块，整合了BRAM、矩阵写入模块和矩阵读取模块，提供统一的矩阵存储管理接口。支持8个矩阵槽位的读写操作，并自动处理读写冲突。

## 模块参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `MAX_MEMORY_MATRIXES` | 8 | 最大矩阵块数量 |
| `BLOCK_SIZE` | 1152 | 每个矩阵块大小（32bit字）|
| `DATA_WIDTH` | 32 | 数据位宽 |
| `DEPTH` | 9216 | BRAM总深度 (8 × 1152) |
| `ADDR_WIDTH` | 14 | 地址位宽 |

## 端口定义

### 时钟和复位

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `clk` | input | 1 | 时钟信号 |
| `rst_n` | input | 1 | 低电平异步复位 |

### 写入接口

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `write_req` | input | 1 | 写入请求信号 |
| `write_matrix_id` | input | 3 | 要写入的矩阵编号 (0~7) |
| `write_rows` | input | 8 | 矩阵真实行数 |
| `write_cols` | input | 8 | 矩阵真实列数 |
| `write_matrix_name` | input | 64 | 矩阵名称（8个字符）|
| `write_data_in` | input | 32 | 矩阵数据输入 |
| `write_data_valid` | input | 1 | 写数据有效信号 |
| `write_done` | output | 1 | 写入完成信号 |
| `writer_ready` | output | 1 | 写入器就绪信号 |

### 读取接口

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `read_req` | input | 1 | 读取请求信号 |
| `read_matrix_id` | input | 3 | 要读取的矩阵编号 (0~7) |
| `read_data_req` | input | 1 | 请求读取下一个数据 |
| `read_done` | output | 1 | 读取完成信号 |
| `reader_ready` | output | 1 | 读取器就绪信号 |
| `read_rows` | output | 8 | 读取的矩阵行数 |
| `read_cols` | output | 8 | 读取的矩阵列数 |
| `read_matrix_name` | output | 64 | 读取的矩阵名称 |
| `read_meta_valid` | output | 1 | 元数据有效信号 |
| `read_data_out` | output | 32 | 矩阵数据输出 |
| `read_data_valid` | output | 1 | 数据有效信号 |

## 核心功能

### 1. 矩阵存储空间划分

BRAM总容量（9216个32bit字）被均分为8个矩阵块：

| 槽位ID | 地址范围 | 容量 |
|--------|---------|------|
| 0 | 0 ~ 1151 | 1152个字 |
| 1 | 1152 ~ 2303 | 1152个字 |
| 2 | 2304 ~ 3455 | 1152个字 |
| 3 | 3456 ~ 4607 | 1152个字 |
| 4 | 4608 ~ 5759 | 1152个字 |
| 5 | 5760 ~ 6911 | 1152个字 |
| 6 | 6912 ~ 8063 | 1152个字 |
| 7 | 8064 ~ 9215 | 1152个字 |

每个槽位的存储格式：

- **地址 0**: 元数据 [31:24]=行数, [23:16]=列数
- **地址 1-2**: 矩阵名称（64bit）
- **地址 3~1151**: 矩阵数据（最多1149个元素）

### 2. 读写仲裁机制

**写优先策略：**

- 当写入器活跃时（`!writer_ready` 或 `write_req = 1`），禁止读操作
- 读取请求会被自动屏蔽，直到写入完成
- 保证数据一致性，避免读写冲突

**仲裁逻辑：**

```systemverilog
if (write_active) {
    // BRAM连接到写入模块
    bram_wr_en = writer_bram_wr_en;
    bram_addr = writer_bram_addr;
    bram_din = writer_bram_din;
} else {
    // BRAM连接到读取模块
    bram_wr_en = 0;
    bram_addr = reader_bram_addr;
}
```

## 使用方法

### 基本使用流程

```text
1. 复位系统
2. 等待 writer_ready = 1 和 reader_ready = 1
3. 执行写入或读取操作
4. 等待操作完成（write_done 或 read_done）
5. 重复步骤3-4
```

### 示例1: 完整的写入-读取流程

```systemverilog
// 1. 系统初始化
rst_n = 0;
repeat(5) @(posedge clk);
rst_n = 1;
repeat(5) @(posedge clk);

// 2. 写入3×3矩阵到槽位0
wait(writer_ready);
@(posedge clk);
write_req <= 1'b1;
write_matrix_id <= 3'd0;
write_rows <= 8'd3;
write_cols <= 8'd3;
write_matrix_name <= "Matrix_A";
@(posedge clk);
write_req <= 1'b0;

// 等待元数据写入
repeat(4) @(posedge clk);

// 写入9个数据元素
for (int i = 0; i < 9; i++) begin
    write_data_in <= matrix_data[i];
    write_data_valid <= 1'b1;
    @(posedge clk);
end
write_data_valid <= 1'b0;

// 等待写入完成
wait(write_done);
@(posedge clk);

// 3. 读取刚写入的矩阵
wait(reader_ready);
@(posedge clk);
read_req <= 1'b1;
read_matrix_id <= 3'd0;
@(posedge clk);
read_req <= 1'b0;

// 等待并获取元数据
wait(read_meta_valid);
@(posedge clk);
$display("读取矩阵: %s, 大小: %0dx%0d", 
         read_matrix_name, read_rows, read_cols);

// 读取数据
for (int i = 0; i < 9; i++) begin
    read_data_req <= 1'b1;
    @(posedge clk);
    read_data_req <= 1'b0;
    @(posedge clk);
    if (read_data_valid) begin
        $display("数据[%0d] = %0d", i, read_data_out);
    end
end

wait(read_done);
```

### 示例2: 写入多个矩阵

```systemverilog
// 写入矩阵A到槽位0
write_matrix(3'd0, 8'd3, 8'd3, "Matrix_A", data_a);
wait(write_done);

// 写入矩阵B到槽位1
write_matrix(3'd1, 8'd2, 8'd4, "Matrix_B", data_b);
wait(write_done);

// 写入矩阵C到槽位2
write_matrix(3'd2, 8'd4, 8'd4, "Matrix_C", data_c);
wait(write_done);
```

### 示例3: 批量读取验证

```systemverilog
// 验证多个矩阵
for (int slot = 0; slot < 3; slot++) begin
    read_matrix(slot);
    wait(read_done);
    verify_matrix(slot);
end
```

## 性能特性

### 写入性能

- **元数据写入**: 固定3个时钟周期
- **数据写入**: 每个元素1个时钟周期（当`write_data_valid = 1`时）
- **总写入时间**: 3 + (rows × cols) 个时钟周期

### 读取性能

- **元数据读取**: 固定6个时钟周期
- **单个数据读取**: 2个时钟周期（发起请求1周期 + BRAM延迟1周期）
- **总读取时间**: 6 + 2 × (rows × cols) 个时钟周期

### 示例计算

对于3×3矩阵（9个元素）：

- 写入时间: 3 + 9 = 12个时钟周期
- 读取时间: 6 + 2×9 = 24个时钟周期

## 重要注意事项

### 1. 读写互斥

- **写操作优先**: 写入时自动禁止读取
- **等待就绪**: 操作前必须检查相应的就绪信号
- **避免冲突**: 不要同时发起读写请求

### 2. 时序要求

- 所有输入信号应在时钟上升沿前稳定
- 输出信号在时钟上升沿后有效
- 遵循BRAM的1周期读延迟

### 3. 容量限制

- 每个槽位最多存储1149个元素（受BLOCK_SIZE限制）
- 矩阵名称固定为8个ASCII字符（64bit）
- 支持的最大矩阵尺寸示例：
  - 33×33 = 1089个元素 ✓
  - 34×34 = 1156个元素 ✗ (超出容量)

### 4. 数据持久性

- BRAM内容在复位时**不会**清除
- 覆盖写入会完全替换原有数据
- 未使用的槽位保持上电时的随机值
