# 矩阵写入模块 (Matrix Writer)

## 概述

矩阵写入模块负责将矩阵数据（包含元数据）写入到指定的BRAM矩阵块中。支持8个矩阵槽位，每个槽位可存储一个完整的矩阵及其元数据。

## 模块参数

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `MAX_MEMORY_MATRIXES` | 8 | 最大矩阵块数量 |
| `BLOCK_SIZE` | 1152 | 每个矩阵块大小（32bit字）|
| `DATA_WIDTH` | 32 | 数据位宽 |
| `ADDR_WIDTH` | 14 | 地址位宽 |

## 端口定义

### 时钟和复位

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `clk` | input | 1 | 时钟信号 |
| `rst_n` | input | 1 | 低电平异步复位 |

### 写入请求接口

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `write_req` | input | 1 | 写入请求信号（脉冲） |
| `matrix_id` | input | 3 | 矩阵编号 (0~7) |
| `rows` | input | 8 | 矩阵真实行数 |
| `cols` | input | 8 | 矩阵真实列数 |
| `matrix_name` | input | 64 | 矩阵名称（8个ASCII字符）|
| `data_in` | input | 32 | 矩阵数据输入 |
| `data_valid` | input | 1 | 数据有效信号 |
| `write_done` | output | 1 | 写入完成信号 |
| `writer_ready` | output | 1 | 写入器就绪信号 |

### BRAM接口

| 端口 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `bram_wr_en` | output | 1 | BRAM写使能 |
| `bram_addr` | output | ADDR_WIDTH | BRAM地址 |
| `bram_din` | output | DATA_WIDTH | BRAM写入数据 |

## 存储格式

每个矩阵块（1152个32bit字）的存储格式如下：

| 地址偏移 | 内容 | 格式 |
|---------|------|------|
| 0 | 元数据0 | [31:24]=行数, [23:16]=列数, [15:0]=保留 |
| 1 | 元数据1 | 矩阵名称低32位 |
| 2 | 元数据2 | 矩阵名称高32位 |
| 3~1151 | 矩阵数据 | 按行优先顺序存储（最多1149个元素）|

**地址计算：** 矩阵ID的基地址 = `matrix_id * BLOCK_SIZE`

## 工作流程

### 状态机

模块内部使用状态机控制写入过程：

```text
IDLE → WRITE_META0 → WRITE_META1 → WRITE_META2 → WRITE_DATA → DONE → IDLE
```

| 状态 | 说明 |
|------|------|
| `IDLE` | 空闲状态，等待写入请求 |
| `WRITE_META0` | 写入元数据字0（行数、列数）|
| `WRITE_META1` | 写入元数据字1（名称低32位）|
| `WRITE_META2` | 写入元数据字2（名称高32位）|
| `WRITE_DATA` | 写入矩阵数据 |
| `DONE` | 写入完成 |

### 写入时序

1. **初始化阶段**
   - 确保 `writer_ready = 1`
   - 准备好矩阵元数据和数据

2. **发起写入请求**

   ```text
   时钟周期 0: write_req = 1, matrix_id = X, rows = R, cols = C, matrix_name = "NAME"
   时钟周期 1: write_req = 0
   ```

3. **元数据写入（自动完成，共3个周期）**
   - 周期 1: 写入地址0（行数、列数）
   - 周期 2: 写入地址1（名称低32位）
   - 周期 3: 写入地址2（名称高32位）

4. **矩阵数据写入**

   ```text
   每当 data_valid = 1 时：
     - 当前周期的 data_in 被写入BRAM
     - 内部地址自动递增
     - 写入计数器递增
   ```

5. **完成**
   - 当所有数据（rows × cols 个元素）写入完成后
   - `write_done` 信号拉高1个周期
   - 返回 `IDLE` 状态

## 使用示例

### 示例1: 写入3×3矩阵

```systemverilog
// 假设时钟为clk，已复位

// 等待写入器就绪
wait(writer_ready);

// 发起写入请求（写入到槽位0）
@(posedge clk);
write_req <= 1'b1;
matrix_id <= 3'd0;
rows <= 8'd3;
cols <= 8'd3;
matrix_name <= "Matrix_A";  // 8个字符
@(posedge clk);
write_req <= 1'b0;

// 等待元数据写入完成（约4个周期）
repeat(4) @(posedge clk);

// 写入9个矩阵元素
for (int i = 0; i < 9; i++) begin
    data_in <= matrix_data[i];
    data_valid <= 1'b1;
    @(posedge clk);
end
data_valid <= 1'b0;

// 等待写入完成
wait(write_done);
```

### 示例2: 写入2×4矩阵

```systemverilog
// 写入到槽位3
write_req <= 1'b1;
matrix_id <= 3'd3;
rows <= 8'd2;
cols <= 8'd4;
matrix_name <= "TestMat2";
@(posedge clk);
write_req <= 1'b0;

repeat(4) @(posedge clk);

// 写入8个元素
for (int i = 0; i < 8; i++) begin
    data_in <= test_data[i];
    data_valid <= 1'b1;
    @(posedge clk);
end
data_valid <= 1'b0;

wait(write_done);
```

## 重要注意事项

1. **写入请求**
   - `write_req` 应该是一个单周期脉冲
   - 发起请求后，元数据会在请求时被锁存

2. **数据有效信号**
   - `data_valid` 控制何时写入矩阵数据
   - 可以连续写入，也可以间隔写入
   - 必须恰好写入 `rows × cols` 个数据

3. **覆盖写入**
   - 新写入会完全覆盖原有槽位的所有内容
   - 无需预先清空

4. **就绪信号**
   - `writer_ready = 0` 表示写入器正在工作
   - 必须等待 `writer_ready = 1` 才能发起新的写入请求

5. **数据范围限制**
   - 最大矩阵大小：1149个元素（受BLOCK_SIZE限制）
   - 矩阵名称：恰好8个ASCII字符（64bit）
